#!/bin/bash
# Task: T5.6.1 - Smoke Tests Script
# Generated by: cicd-monitoring-agent
# Reference: phase5-spec.md Section 6.1, constitution.md Section 6

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
ENVIRONMENT="${1:-staging}"
NAMESPACE="todo-${ENVIRONMENT}"
MAX_RETRIES=5
RETRY_DELAY=10

# Functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_test() {
    echo -e "${BLUE}[TEST]${NC} $1"
}

log_pass() {
    echo -e "${GREEN}[PASS]${NC} $1"
}

log_fail() {
    echo -e "${RED}[FAIL]${NC} $1"
}

# Get service URL
get_service_url() {
    local SERVICE_NAME=$1

    # Try to get ingress URL first
    INGRESS_HOST=$(kubectl get ingress -n "${NAMESPACE}" -o jsonpath='{.items[0].spec.rules[0].host}' 2>/dev/null || echo "")

    if [ -n "$INGRESS_HOST" ]; then
        echo "https://${INGRESS_HOST}"
    else
        # Fallback to port-forward
        log_warn "No ingress found, using port-forward"
        kubectl port-forward -n "${NAMESPACE}" "svc/${SERVICE_NAME}" 8080:80 &
        PORT_FORWARD_PID=$!
        sleep 3
        echo "http://localhost:8080"
    fi
}

# Test backend health endpoint
test_backend_health() {
    log_test "Testing backend health endpoint..."

    local BACKEND_URL=$(get_service_url "todo-backend")
    local HEALTH_URL="${BACKEND_URL}/health"

    for i in $(seq 1 $MAX_RETRIES); do
        if curl -f -s -o /dev/null -w "%{http_code}" "${HEALTH_URL}" | grep -q "200"; then
            log_pass "Backend health check passed"
            return 0
        else
            log_warn "Attempt $i/$MAX_RETRIES failed, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
        fi
    done

    log_fail "Backend health check failed after $MAX_RETRIES attempts"
    return 1
}

# Test frontend health endpoint
test_frontend_health() {
    log_test "Testing frontend health endpoint..."

    local FRONTEND_URL=$(get_service_url "todo-frontend")

    for i in $(seq 1 $MAX_RETRIES); do
        if curl -f -s -o /dev/null -w "%{http_code}" "${FRONTEND_URL}" | grep -q "200"; then
            log_pass "Frontend health check passed"
            return 0
        else
            log_warn "Attempt $i/$MAX_RETRIES failed, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
        fi
    done

    log_fail "Frontend health check failed after $MAX_RETRIES attempts"
    return 1
}

# Test backend API endpoints
test_backend_api() {
    log_test "Testing backend API endpoints..."

    local BACKEND_URL=$(get_service_url "todo-backend")

    # Test GET /tasks endpoint
    if curl -f -s "${BACKEND_URL}/api/tasks" > /dev/null; then
        log_pass "GET /api/tasks endpoint working"
    else
        log_fail "GET /api/tasks endpoint failed"
        return 1
    fi

    # Test POST /tasks endpoint (create task)
    local RESPONSE=$(curl -s -X POST "${BACKEND_URL}/api/tasks" \
        -H "Content-Type: application/json" \
        -d '{"title":"Smoke test task","description":"Testing deployment"}')

    if echo "$RESPONSE" | grep -q "id"; then
        log_pass "POST /api/tasks endpoint working"
    else
        log_fail "POST /api/tasks endpoint failed"
        return 1
    fi
}

# Test database connectivity
test_database_connectivity() {
    log_test "Testing database connectivity..."

    # Check if backend pods can connect to database
    local BACKEND_POD=$(kubectl get pods -n "${NAMESPACE}" -l app=todo-backend -o jsonpath='{.items[0].metadata.name}')

    if [ -z "$BACKEND_POD" ]; then
        log_fail "No backend pod found"
        return 1
    fi

    # Check logs for database connection errors
    if kubectl logs -n "${NAMESPACE}" "$BACKEND_POD" --tail=50 | grep -qi "database.*error"; then
        log_fail "Database connection errors found in logs"
        return 1
    else
        log_pass "Database connectivity check passed"
    fi
}

# Test Kafka connectivity
test_kafka_connectivity() {
    log_test "Testing Kafka connectivity..."

    # Check if Dapr sidecars are running
    local DAPR_PODS=$(kubectl get pods -n "${NAMESPACE}" -o jsonpath='{.items[*].spec.containers[*].name}' | grep -o "daprd" | wc -l)

    if [ "$DAPR_PODS" -gt 0 ]; then
        log_pass "Dapr sidecars are running ($DAPR_PODS found)"
    else
        log_warn "No Dapr sidecars found"
    fi

    # Check Dapr components
    if kubectl get components -n "${NAMESPACE}" &> /dev/null; then
        local COMPONENT_COUNT=$(kubectl get components -n "${NAMESPACE}" --no-headers | wc -l)
        log_pass "Dapr components loaded ($COMPONENT_COUNT found)"
    else
        log_warn "Cannot check Dapr components"
    fi
}

# Test pod health
test_pod_health() {
    log_test "Testing pod health..."

    # Check if all pods are running
    local NOT_RUNNING=$(kubectl get pods -n "${NAMESPACE}" --no-headers | grep -v "Running" | wc -l)

    if [ "$NOT_RUNNING" -eq 0 ]; then
        log_pass "All pods are running"
    else
        log_fail "$NOT_RUNNING pods are not running"
        kubectl get pods -n "${NAMESPACE}"
        return 1
    fi

    # Check if all pods are ready
    local NOT_READY=$(kubectl get pods -n "${NAMESPACE}" --no-headers | grep "0/" | wc -l)

    if [ "$NOT_READY" -eq 0 ]; then
        log_pass "All pods are ready"
    else
        log_fail "$NOT_READY pods are not ready"
        kubectl get pods -n "${NAMESPACE}"
        return 1
    fi
}

# Test resource usage
test_resource_usage() {
    log_test "Testing resource usage..."

    # Get pod resource usage
    kubectl top pods -n "${NAMESPACE}" 2>/dev/null || log_warn "Metrics server not available"

    log_pass "Resource usage check completed"
}

# Cleanup
cleanup() {
    if [ -n "$PORT_FORWARD_PID" ]; then
        kill $PORT_FORWARD_PID 2>/dev/null || true
    fi
}

# Main execution
main() {
    log_info "Starting smoke tests for ${ENVIRONMENT} environment..."
    log_info "Namespace: ${NAMESPACE}"

    trap cleanup EXIT

    local FAILED_TESTS=0

    # Run all tests
    test_pod_health || ((FAILED_TESTS++))
    test_database_connectivity || ((FAILED_TESTS++))
    test_kafka_connectivity || ((FAILED_TESTS++))
    test_backend_health || ((FAILED_TESTS++))
    test_frontend_health || ((FAILED_TESTS++))
    test_backend_api || ((FAILED_TESTS++))
    test_resource_usage || ((FAILED_TESTS++))

    echo ""
    if [ $FAILED_TESTS -eq 0 ]; then
        log_info "✅ All smoke tests passed!"
        exit 0
    else
        log_error "❌ $FAILED_TESTS smoke test(s) failed"
        exit 1
    fi
}

# Validate environment argument
if [[ ! "${ENVIRONMENT}" =~ ^(staging|production)$ ]]; then
    log_error "Invalid environment: ${ENVIRONMENT}"
    echo "Usage: $0 <staging|production>"
    exit 1
fi

# Run main function
main "$@"

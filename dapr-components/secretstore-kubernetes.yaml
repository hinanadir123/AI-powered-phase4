# Dapr Secret Store Component: Kubernetes Secrets
# Task: T5.1.2 - Generate Dapr Component YAML Files
# Spec Reference: phase5-spec.md Section 4.3 (Dapr Components)
# Constitution: constitution.md v5.0 Section 4.3 (Dapr Components)
#
# This component enables access to Kubernetes Secrets via Dapr Secret Store API.
# It provides secure storage and retrieval of sensitive data like API keys,
# database credentials, and authentication tokens.
#
# Version: 1.0
# Date: 2026-02-15
# Generated by: kafka-dapr-engineer agent

apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: kubernetes-secret-store
  namespace: default
spec:
  type: secretstores.kubernetes
  version: v1
  metadata:
    - name: name
      value: "kubernetes"
    - name: scopes
      value: "todo-api,reminder-worker,notification-service"

---
# Kubernetes Secrets to Create
#
# 1. PostgreSQL Database Credentials
# kubectl create secret generic postgres-secrets \
#   --from-literal=connectionString="host={POSTGRES_HOST} port=5432 user={POSTGRES_USER} password={POSTGRES_PASSWORD} dbname={POSTGRES_DB} sslmode=require" \
#   --namespace={NAMESPACE}
#
# 2. Kafka Credentials (if using SASL authentication)
# kubectl create secret generic kafka-secrets \
#   --from-literal=username="{KAFKA_USERNAME}" \
#   --from-literal=password="{KAFKA_PASSWORD}" \
#   --from-literal=brokers="{KAFKA_BROKERS}" \
#   --namespace={NAMESPACE}
#
# 3. API Keys and Tokens
# kubectl create secret generic api-secrets \
#   --from-literal=openai-api-key="{OPENAI_API_KEY}" \
#   --from-literal=jwt-secret="{JWT_SECRET}" \
#   --from-literal=encryption-key="{ENCRYPTION_KEY}" \
#   --namespace={NAMESPACE}
#
# 4. Email Service Credentials (for reminder notifications)
# kubectl create secret generic email-secrets \
#   --from-literal=smtp-host="{SMTP_HOST}" \
#   --from-literal=smtp-port="{SMTP_PORT}" \
#   --from-literal=smtp-username="{SMTP_USERNAME}" \
#   --from-literal=smtp-password="{SMTP_PASSWORD}" \
#   --namespace={NAMESPACE}
#
# 5. Cloud Provider Credentials (for cloud deployment)
# kubectl create secret generic cloud-secrets \
#   --from-literal=azure-client-id="{AZURE_CLIENT_ID}" \
#   --from-literal=azure-client-secret="{AZURE_CLIENT_SECRET}" \
#   --from-literal=azure-tenant-id="{AZURE_TENANT_ID}" \
#   --namespace={NAMESPACE}

---
# Secret Store Usage Examples
#
# Get Secret via Dapr API:
# GET http://localhost:3500/v1.0/secrets/secretstore-kubernetes/postgres-secrets/connectionString
#
# Response:
# {
#   "connectionString": "host=... port=5432 ..."
# }
#
# Get All Keys from a Secret:
# GET http://localhost:3500/v1.0/secrets/secretstore-kubernetes/api-secrets
#
# Response:
# {
#   "openai-api-key": "sk-...",
#   "jwt-secret": "...",
#   "encryption-key": "..."
# }
#
# Using Secrets in Code (Node.js example):
# const response = await fetch('http://localhost:3500/v1.0/secrets/secretstore-kubernetes/postgres-secrets/connectionString');
# const secret = await response.json();
# const connectionString = secret.connectionString;
#
# Using Secrets in Code (Python example):
# import requests
# response = requests.get('http://localhost:3500/v1.0/secrets/secretstore-kubernetes/postgres-secrets/connectionString')
# secret = response.json()
# connection_string = secret['connectionString']

---
# Secret Management Best Practices
#
# 1. Never commit secrets to version control
#    - Use .gitignore to exclude secret files
#    - Use environment variables or secret management tools
#
# 2. Rotate secrets regularly
#    - Database passwords: Every 90 days
#    - API keys: Every 180 days
#    - JWT secrets: Every 365 days
#
# 3. Use separate secrets for different environments
#    - Development: dev-postgres-secrets
#    - Staging: staging-postgres-secrets
#    - Production: prod-postgres-secrets
#
# 4. Limit secret access with RBAC
#    - Create service accounts with minimal permissions
#    - Use namespace isolation for multi-tenant scenarios
#
# 5. Enable secret encryption at rest
#    - Kubernetes encrypts secrets by default
#    - Use cloud provider KMS for additional security
#
# 6. Audit secret access
#    - Enable Kubernetes audit logging
#    - Monitor secret access patterns
#    - Alert on suspicious access attempts
#
# 7. Use external secret management (optional)
#    - Azure Key Vault
#    - Google Secret Manager
#    - HashiCorp Vault
#    - AWS Secrets Manager

---
# Kubernetes RBAC Configuration
#
# Create a service account for Dapr to access secrets:
#
# apiVersion: v1
# kind: ServiceAccount
# metadata:
#   name: dapr-secret-reader
#   namespace: {NAMESPACE}
# ---
# apiVersion: rbac.authorization.k8s.io/v1
# kind: Role
# metadata:
#   name: secret-reader
#   namespace: {NAMESPACE}
# rules:
# - apiGroups: [""]
#   resources: ["secrets"]
#   verbs: ["get", "list"]
# ---
# apiVersion: rbac.authorization.k8s.io/v1
# kind: RoleBinding
# metadata:
#   name: dapr-secret-reader-binding
#   namespace: {NAMESPACE}
# subjects:
# - kind: ServiceAccount
#   name: dapr-secret-reader
#   namespace: {NAMESPACE}
# roleRef:
#   kind: Role
#   name: secret-reader
#   apiGroup: rbac.authorization.k8s.io

---
# Secret Verification Commands
#
# List all secrets in namespace:
# kubectl get secrets -n {NAMESPACE}
#
# Describe a specific secret:
# kubectl describe secret postgres-secrets -n {NAMESPACE}
#
# View secret data (base64 encoded):
# kubectl get secret postgres-secrets -n {NAMESPACE} -o yaml
#
# Decode secret value:
# kubectl get secret postgres-secrets -n {NAMESPACE} -o jsonpath='{.data.connectionString}' | base64 --decode
#
# Test Dapr secret access:
# kubectl exec -it <pod-name> -n {NAMESPACE} -- curl http://localhost:3500/v1.0/secrets/secretstore-kubernetes/postgres-secrets/connectionString

---
# Environment-Specific Secret Configuration
#
# Local Development (Minikube):
# - Use simple secrets with placeholder values
# - Store in local-secrets.yaml (not committed to git)
# - Apply with: kubectl apply -f local-secrets.yaml
#
# Staging Environment:
# - Use cloud provider secret management
# - Sync secrets from Azure Key Vault or Google Secret Manager
# - Use External Secrets Operator for automatic sync
#
# Production Environment:
# - Use cloud provider KMS for encryption
# - Enable secret rotation policies
# - Use separate namespaces for isolation
# - Enable audit logging for compliance

---
# Troubleshooting
#
# Issue: "Secret not found" error
# Solution: Verify secret exists in correct namespace
# kubectl get secret <secret-name> -n {NAMESPACE}
#
# Issue: "Permission denied" error
# Solution: Check RBAC permissions for service account
# kubectl auth can-i get secrets --as=system:serviceaccount:{NAMESPACE}:dapr-secret-reader -n {NAMESPACE}
#
# Issue: Cached secret not updating
# Solution: Restart Dapr sidecar or wait for cache TTL expiration
# kubectl rollout restart deployment <deployment-name> -n {NAMESPACE}
#
# Issue: Secret value is base64 encoded
# Solution: Dapr automatically decodes base64 values
# If still encoded, decode manually: echo "<value>" | base64 --decode
